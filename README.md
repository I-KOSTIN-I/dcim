 Тестовое задание - Python/Flask/SQL
Принцип выполнения задания
Задание в первую очередь направлено на ознакомление с типовыми для нашего отдела задачами и используемыми технологиями. Во время выполнения задания, разумеется, не запрещается пользоваться любыми источниками информации (как и во время реального рабочего процесса). Но важно понимать, что результат работы поможет не только нам понять уровень владения кандидатом используемыми технологиями, но и вам понять насколько уверенно вы справляетесь с подобными задачами.
Лучшим итогом выполнения задания будет одно приложение, обращаясь к которому можно получить результат работы функций, реализованных при выполнении перечисленных ниже задач. То есть, каждое следующее задание в идеале расширяет функциональность приложения, реализованного в первом задании. Если такой подход покажется слишком сложным, задания можно выполнять и отдельно друг от друга.
После выполнения задания, вероятно, последует устное обсуждение решения. Поэтому, решения, бездумно скопированные со StackOverflow, могут сыграть с вами злую шутку.
Для многих пунктов задания будет предоставлена возможность выбора из нескольких вариантов его реализации. Они делятся по сложности. Не обязательно делать самым сложным способом. Лучше выбрать тот, которым вы уверенно владеете. Если времени и сил осталось много, можно сделать решения даже во всех возможных вариантах. В этом плане ограничений никаких нет. Чем больше нам удастся увидеть кода - тем лучше мы сможем понять навыки кандидата. Можно даже расширить какую-то функциональность решений (если это не идёт вразрез с ТЗ, конечно).
Не стоит сильно переживать, если какие-то задания не будут получаться. Не стоит также зацикливаться на одном задании. Повторюсь - лучше делать только те задания, которые не вызывают трудностей, чем писать код, который работает на копипасте и везении.
Если условия какой-то задачи описаны недостаточно понятно, можно уточнить их, написав на корпоративную почту автора: ogorov@selectel.ru

 Условия заданий
1. Создание Flask - Приложения
Нужно развернуть приложение на основе Flask, которое будет принимать запросы на локальном хосте на порту :5005
Достаточно чтобы сервер отдавал по адресу localhost:5005/ простейшую страницу. К примеру с надписью Hello World
Приложение должно общаться с базой при помощи SQLAlchemy. База - желательно Postgres, но можно использовать любую привычную альтернативу.
Базу нужно заполнить следующими тестовыми данными (и создать их SQLAlchemy модели, конечно):
P.S. ID объектов на самом деле создаются автоматически. В таблицах они приведены только для указания связей между строками. В созданных вами таблицах, ID, конечно, могут быть другими.
Комната (public.room)
    id (pk)
name <text>
1
Room1
2
Room2
3
Room3
4
Room4
     Стойка (public.rack)
        id (pk)
name <text>
size <int>
state <text>
customer (fk)
room_id (fk)
1
Rack1
42
occupied
1
1
2
Rack2
42
occupied
2
1
3
Rack3
21
free
3
1
4
Rack4
42
occupied
1
2
     
         5
Rack5
42
free
1
2
6
Rack6
47
free
2
3
7
Rack7
42
occupied
1
3
8
Rack8
21
occupied
1
3
    Клиент (public.customer)
    id (pk)
name <text>
1
Клиент-1
2
Клиент-2
3
Клиент-3
    Варианты реализации сервера:
1. Хороший - Папка с файлами приложения и списком зависимостей в виде
requerements.txt. Приложение должно запускаться в venv стандартными
командами Flask или bash скриптом после установки зависимостей.
2. Ещё лучше - Добавить в папку Dockerfile, который развернёт приложение
готовое к работе сразу в виде Docker-контейнера. (база может при этом быть
вне контейнера)
3. Идеально - Docker-Compose - файл, который соберёт приложение в виде стека
контейнеров с приложением и базой (база в отдельном контейнере)
Варианты заполнения базы:
1. На крайний случай - Записать данные в базу напрямую
2. Нормально - Записывать данные внутри приложения при старте, используя
ORM (придётся их затирать каждый раз)
3. Идеально - Прописать заполнение таблиц в файле миграции
2. SQL/ORM выборки из БД
На основе данных, занесённых в базу в прошлом задании, нужно создать несколько выборок.
Если задача решается на БД отличной от Postgres, важно понимать отличия в работе разных БД. Некоторые запросы верные для других БД могут не сработать в postgres и нужно осознавать почему так происходит.
Важное замечание: Логику задания нужно как можно сильнее перенести на сторону БД. Некоторые вещи можно сделать несколькими выборками или одной простой, но затем доработать её питоном. Такой результат тоже будет принят, но оценится ниже.

 1. Простые выборки
Получить все строки со всеми полями из каждой таблицы (3 разных запроса)
2. Составные выборки
Получить список занятых (status == ‘occupied’) стоек с именем комнаты, в которой каждая стойка находится, и именем клиента, которому она принадлежит.
Поля в результирующей таблице: id стойки, name стойки, name клиента, name комнаты
3. Выборка клиентов по комнате
Получить список всех комнат с прикреплённым к каждой массивом из ID тех клиентов, у которых есть занятые (status == ‘occupied’) стойки в этой комнате. Поля в результирующей таблице: id комнаты, name комнаты, массив id клиентов
4. Узнать стойку с максимальной высотой для каждой комнаты
Нужно получить список всех комнат и для каждой определить стойку внутри неё, у которой поле size имеет наибольшее значение. Если таких стоек несколько, можно выбрать любую.
Поля в результирующей таблице: id комнаты, id стойки, size стойки
Варианты выполнения запросов:
1. На крайний случай - Просто файлы с текстом полученных выборок
(желательно под Postgres)
2. Неплохо - Функции, запускающиеся внутри приложения и выводящие результат
в читаемом формате в консоль
3. Отлично - API-методы (REST), доступные через GET запросы к урлам с
именами, дающими понять о каком запросе идёт речь. Формат возвращаемых данных - JSON-массив, где строки результата представлены в виде словарей, а поля в каждом словаре - столбцы полученной таблицы.
4. Идеально (для нас) - API-запросы, аналогичные предыдущему варианту, только вместо REST использовать JSON-RPC
3. Декораторы
1. Создать четыре функции, производящие математические операции с произвольным числом входящих аргументов.
Каждая функция соответствует одной математической операции. Результатом каждой функции будет произведение одной математической операции “по цепочке” с каждым параметром, используя результат прошлой операции для следующей операции.

 Пример для сложения: 1+2+3+4 = 10
Функции должны выглядеть приблизительно следующим образом: def sum(a, b, c, d):
return 0+((a+b)+c)+d
Единственным отличием для ваших функций будет то, что они должны принимать произвольное количество аргументов. То есть, такой вызов должен сработать: sum(1,2,3,4,5,6,7,8,9)
2. Написать информационный декоратор
Создать декоратор, который будет выводить в консоль имя функции, которую он декорирует, при её вызове.
Декоратор должен быть применён ко всем функциям из предыдущего пункта.
То есть, при вызове функции sum(1,2,3), в консоли должна появиться запись примерно следующего содержания: Function ‘sum’ was called.
3. Написать декоратор, подменяющий аргументы
Создать и применить ко всем функциям этого задания декоратор, который будет умножать последний аргумент декорируемой функции на произвольный коэффициент перед её выполнением.
То есть, декоратор должен принимать на вход число, на которое будет умножен последний переданный в функцию аргумент.
4. Добавить в каждую функцию необязательный аргумент, отвечающий за порядок выполнение операций
Этот аргумент должен определять порядок в котором произведутся математические операции. То есть: при обычном порядке переданные в sum(1,2,3,4) произведут цепочку ((1+2)+3)+4, а в обратном порядке получится цепочка ((4+3)+2)+1
Варианты выполнения запросов:
1. Неплохо - Функции, запускающиеся внутри приложения и выводящие результат
в читаемом формате в консоль
2. Отлично - API-методы (REST), доступные через GET запросы к урлам с
именами, дающими понять о каком запросе идёт речь. Формат ответа - JSON с ответом в виде числа или более сложной конструкции, содержащей результат полученный от функции.
3. Идеально (для нас) - API-запросы, аналогичные предыдущему варианту, только вместо REST использовать JSON-RPC
